#![allow(non_snake_case)]
use serde::{ Deserialize, Serialize };
use std::collections::HashMap;
use std::process::Command;
use std::process::ExitStatus;
use std::fmt;

#[derive(Debug)]
struct AddrError {
    status: ExitStatus,
}

impl fmt::Display for AddrError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.status)
    }
}

impl std::error::Error for AddrError {
    fn description(&self) -> &str {
        "bitcoin return status"
    }

    fn cause(&self) -> Option<&dyn std::error::Error> {
        None
    }
}

#[derive(Clone, Debug)]
pub struct Bitcoin {
    pub app: String,
    pub rpcuser: String,
    pub rpcpassword: String,
    pub rpcport: String,
    pub rpcconnect: String,
}

#[derive(Serialize, Deserialize)]
pub struct MultiSig {
    pub address: String,
    pub redeemScript: String,
}

impl Bitcoin {
    fn trimmed_output(to_trim: Vec<u8>) -> String {
        let to_trim = String::from_utf8(to_trim).unwrap_or(String::new());
        String::from(to_trim.trim())
    }

    fn exec_command(&self, cmd: &str, args: Vec<String>) -> Result<String, Box<dyn std::error::Error>> {
        let output = Command::new(&*self.app)
            .arg(format!("-rpcconnect={}", self.rpcconnect))
            .arg("-regtest")
            .arg(format!("-rpcuser={}", self.rpcuser))
            .arg(format!("-rpcpassword={}", self.rpcpassword))
            .arg(format!("-rpcport={}", self.rpcport))
            .arg(cmd).args(args).output()?;
        if !output.status.success() {
            return Err(Box::new(
                AddrError {
                    status: output.status
                }));
        }
        Ok(Bitcoin::trimmed_output(output.stdout))
    }

    pub fn getaddr(&self) -> HashMap<String, String> {
        let mut result = HashMap::new();
        match self.exec_command("getnewaddress", Vec::new()) {
            Ok(address) => {
                if address.is_empty() {
                    result.insert(String::from("err"), String::from("No address generated by bitcoind"));
                } else {
                    result.insert(String::from("address"), address);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }

    pub fn dumpprivkey(&self, addr: String) -> HashMap<String, String> {
        let mut args = Vec::new();
        args.push(addr);
        let mut result = HashMap::new();
        match self.exec_command("dumpprivkey", args) {
            Ok(privkey) => {
                if privkey.is_empty() {
                    result.insert(String::from("err"), String::from("No privkey retrieven by bitcoind"));
                } else {
                    result.insert(String::from("privkey"), privkey);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }

    pub fn balance(&self) -> HashMap<String, String> {
        let mut result = HashMap::new();
        match self.exec_command("getbalance", Vec::new()) {
            Ok(balance) => {
                if balance.is_empty() {
                    result.insert(String::from("err"), String::from("No balance generated by bitcoind"));
                } else {
                    result.insert(String::from("balance"), balance);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }

    pub fn createmultisig(&self, n: u32, keys: &Vec<String>) -> HashMap<String, String>{
        let mut args = Vec::new();
        args.push(n.to_string());
        let mut keys_str = String::from("[");
        let mut idx = 0;
        for key in keys {
            idx += 1;
            keys_str += &*format!("\"{}\"", key);
            if idx != keys.len() {
                keys_str += ", ";
            }
        }
        keys_str += "]";
        args.push(keys_str);
        let mut result = HashMap::new();
        match self.exec_command("createmultisig", args) {
            Ok(output) => {
                if output.is_empty() {
                    result.insert(String::from("err"), String::from("No multisig address generated by bitcoind"));
                } else {
                    let ms: MultiSig = serde_json::from_str(&output).unwrap_or(MultiSig {
                        address: String::new(),
                        redeemScript: String::new(),
                    });
                    if !ms.address.is_empty() {
                        result.insert(String::from("address"), ms.address);
                        result.insert(String::from("redeemScript"), ms.redeemScript);
                    } else {
                        result.insert(String::from("err"), String::from("Can't parse multisig result"));
                    }
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        };
        result
    }

    pub fn addmultisigaddress(&self, n: u32, keys: &Vec<String>) -> HashMap<String, String> {
        let mut args = Vec::new();
        args.push(n.to_string());
        let mut keys_str = String::from("[");
        let mut idx = 0;
        for key in keys {
            idx += 1;
            keys_str += &*format!("\"{}\"", key);
            if idx != keys.len() {
                keys_str += ", ";
            }
        }
        keys_str += "]";
        args.push(keys_str);
        let mut result = HashMap::new();
        match self.exec_command("addmultisigaddress", args) {
            Ok(output) => {
                if output.is_empty() {
                    result.insert(String::from("err"), String::from("No multisig address generated by bitcoind"));
                } else {
                    let ms: MultiSig = serde_json::from_str(&output).unwrap_or(MultiSig {
                        address: String::new(),
                        redeemScript: String::new(),
                    });
                    if !ms.address.is_empty() {
                        result.insert(String::from("address"), ms.address);
                        result.insert(String::from("redeemScript"), ms.redeemScript);
                    } else {
                        result.insert(String::from("err"), String::from("Can't parse multisig result"));
                    }
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        };
        result
    }

    pub fn gettransaction(&self, txid: String) -> HashMap<String, String> {
        let mut args = Vec::new();
        args.push(txid);
        let mut result = HashMap::new();
        match self.exec_command("gettransaction", args) {
            Ok(details) => {
                if details.is_empty() {
                    result.insert(String::from("err"), String::from("No details retrieven by bitcoind"));
                } else {
                    result.insert(String::from("details"), details);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }

    pub fn sendtoaddress(&self, bitcoinaddress: String, amount: String) -> HashMap<String, String> {
        let mut args = Vec::new();
        args.push(bitcoinaddress);
        args.push(amount);
        let mut result = HashMap::new();
        match self.exec_command("sendtoaddress", args) {
            Ok(signed) => {
                if signed.is_empty() {
                    result.insert(String::from("err"), String::from("No signed transation retrieven by bitcoind"));
                } else {
                    result.insert(String::from("signed"), signed);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }

    pub fn signmessage(&self, bitcoinaddress: String, message: String) -> HashMap<String, String> {
        let mut args = Vec::new();
        args.push(bitcoinaddress);
        args.push(message);
        let mut result = HashMap::new();
        match self.exec_command("signmessage", args) {
            Ok(txid) => {
                if txid.is_empty() {
                    result.insert(String::from("err"), String::from("No transaction id transation retrieven by bitcoind"));
                } else {
                    result.insert(String::from("txid"), txid);
                }
            },
            Err(e) => {
                result.insert(String::from("err"), format!("{}", e));
            }
        }
        result
    }
    
}